package com.cibo.provenance

import scala.language.implicitConversions
import scala.reflect.ClassTag
import io.circe._

/**
  * Created by ssmith on 9/12/17.
  *
  * Note: The base class FunctionCallWithProvenance[O] is defined in VirtualValue.scala.
  * Since VirtualValue[T] is a sealed trait, all subclasses must be in that file.
  *
  * This template file implements the 22 sub-classes Function{0..21} of call.
  */

/**
  * This is a parameter-type specific subclass of FunctionCallWithProvenance[O].
  *
  * It is an intermediate class above `Function1WithProvenance.Call`, which is
  * in turn used by application-defined subclases of `Function1WithProvenance`.
  * These intermediates are only directly referenced by internal classes.
  * Applications should reference `MyFunction.Call` for full precision.
  *
  * @tparam O           The type of the output.
  *
  * @param v:           The version of the Function0WithProvenance[O] being called.
  * @param implVersion: A lambda that contains the actual execution logic (cross-version).
  */
abstract class Function0CallWithProvenance[O : ClassTag : Encoder : Decoder](v: ValueWithProvenance[Version])(implVersion: (Version) => O) extends FunctionCallWithProvenance[O](v) with Serializable {

  def getInputs: Seq[ValueWithProvenance[_]] = Seq.empty

  // NOTE: Function0 has no inputTuple method, since there is no Tuple0.

  // NOTE: In most cases these methods are overridden by FunctionNWithProvenance.Call to return
  // the same object, but with a more specific known type.

  def resolveInputs(implicit rt: ResultTracker): Function0CallWithProvenance[O] =
    nocopy(duplicate(v.resolve), this)

  def unresolveInputs(implicit rt: ResultTracker): Function0CallWithProvenance[O] =
    nocopy(duplicate(v.unresolve), this)

  def inflateInputs(implicit rt: ResultTracker): Function0CallWithProvenance[O] =
    nocopy(duplicate(v.inflate), this)

  def deflateInputs(implicit rt: ResultTracker): Function0CallWithProvenance[O] =
    nocopy(duplicate(v.inflate), this)

  /*
  def run(implicit rt: ResultTracker): Function0CallResultWithProvenance[O] = {
    val o: O = implVersion(getVersionValue)
    new Function0CallResultWithProvenance(this, VirtualValue(o))(rt.currentAppBuildInfo)
  }
  */

  def newResult(value: VirtualValue[O])(implicit bi: BuildInfo): FunctionCallResultWithProvenance[O]

  def duplicate(vv: ValueWithProvenance[Version]): Function0CallWithProvenance[O]
}

[1..21#
/**
  * This is a parameter-type specific subclass of FunctionCallWithProvenance[O].
  *
  * It is an intermediate class above `Function1WithProvenance.Call`, which is
  * in turn used by application-defined subclases of `Function1WithProvenance`.
  * These intermediates are only directly referenced by internal classes.
  * Applications should reference MyFunction.Call for full precision.
  *
  * @tparam O:          The type of the output.
  * [#@tparam I1:         The type of input 1.#
  * ]
  *
  * @param v:           The version of the Function1WithProvenance[O] being called.
  * @param implVersion: A lambda that contains the actual execution logic, cross-version.
  */
abstract class Function1CallWithProvenance[O : ClassTag : Encoder : Decoder, [#I1#]]([#i1: ValueWithProvenance[I1]#], v: ValueWithProvenance[Version])(implVersion: ([#I1#], Version) => O) extends FunctionCallWithProvenance[O](v) with Serializable {

  def getInputs: Seq[ValueWithProvenance[_]] = Seq([#i1#])

  def inputTuple: Tuple1[[#ValueWithProvenance[I1]#]] = Tuple1([#i1#])

  // NOTE: In most cases these methods are overridden by FunctionNWithProvenance.Call to return
  // the same object, but with a more specific known type.

  def resolveInputs(implicit rt: ResultTracker): Function1CallWithProvenance[O, [#I1#]] =
    nocopy(duplicate([#i1.resolve#], v.resolve), this)

  def unresolveInputs(implicit rt: ResultTracker): Function1CallWithProvenance[O, [#I1#]] =
    nocopy(duplicate([#i1.unresolve#], v.unresolve), this)

  def inflateInputs(implicit rt: ResultTracker): Function1CallWithProvenance[O, [#I1#]] =
    nocopy(duplicate([#i1.inflate#], v.inflate), this)

  def deflateInputs(implicit rt: ResultTracker): Function1CallWithProvenance[O, [#I1#]] =
    nocopy(duplicate([#i1.deflate#], v.inflate), this)

  def run(implicit rt: ResultTracker): Function1CallResultWithProvenance[O, [#I1#]]

  def newResult(value: VirtualValue[O])(implicit bi: BuildInfo): Function1CallResultWithProvenance[O, [#I1#]]

  def duplicate([#v1: ValueWithProvenance[I1]#], vv: ValueWithProvenance[Version]): Function1CallWithProvenance[O, [#I1#]]
}#

]

