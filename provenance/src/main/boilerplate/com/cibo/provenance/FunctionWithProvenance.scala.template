package com.cibo.provenance

/**
  * Created by ssmith on 9/12/17.
  */

import com.cibo.provenance.exceptions.{UnknownVersionException, UnrunnableVersionException}
import scala.language.implicitConversions
import scala.reflect.ClassTag
import io.circe.{Encoder, Decoder}

trait Function0WithProvenance[O] extends FunctionWithProvenance[O] with Serializable {
  self =>

  val currentVersion: Version

  def impl(): O

  def apply(v: ValueWithProvenance[Version] = currentVersion)(implicit ct: ClassTag[O], ec: Encoder[O], dc: Decoder[O]): Call = Call(v)(ct, ec, dc)

  protected def implVersion(v: Version): O = {
    if (v != currentVersion)
      throwInvalidVersionException(v)
    impl()
  }

  case class Call(v: ValueWithProvenance[Version] = currentVersion)(implicit ct: ClassTag[O], ec: Encoder[O], dc: Decoder[O])
    extends Function0CallWithProvenance[O](v)(implVersion) {

      val function = self
      val functionName: String = self.getClass.getName.stripSuffix("$")

      override def toString: String =
        self.getClass.getSimpleName.stripSuffix("$") + "()" // no Tuple0

      override def resolve(implicit rt: ResultTracker): Result =
        super.resolve(rt).asInstanceOf[Result]

      def newResult(output: VirtualValue[O])(implicit bi: BuildInfo): Result =
        Result(this, output)(bi)

      def duplicate(vv: ValueWithProvenance[Version]): Call =
        copy(v)
    
      //
      
      override def resolveInputs(implicit rt: ResultTracker): Call =
        nocopy(duplicate(v.resolve), this)

      override def unresolveInputs(implicit rt: ResultTracker): Call =
        nocopy(duplicate(v.unresolve), this)

      override def inflateInputs(implicit rt: ResultTracker): Call =
        nocopy(duplicate(v.inflate), this)

      override def deflateInputs(implicit rt: ResultTracker): Call =
        nocopy(duplicate(v.inflate), this)

      override def run(implicit rt: ResultTracker): Result = {
        val output: O = implVersion(getVersionValue)
        Result(this, VirtualValue(output))(rt.getCurrentBuildInfo)
      }
  }

  object Call {
    implicit def encoder = Util.rawEncoder[Call]
    implicit def decoder = Util.rawDecoder[Call]
  }

  case class Result(call: Call, data: VirtualValue[O])(implicit bi: BuildInfo)
    extends Function0CallResultWithProvenance(call, data)(bi)

  implicit private def convertResult(r: Function0CallResultWithProvenance[O]): Result =
    Result(r.provenance, r.getOutputVirtual)(r.getOutputBuildInfoBrief)

  implicit private def convertProvenance(f: Function0CallWithProvenance[O]): Call =
    Call(f.getVersion)(f.getOutputClassTag, f.getEncoder, f.getDecoder)
}


[1..21#trait Function1WithProvenance[O, [#I1#]] extends FunctionWithProvenance[O] with Serializable {
  self =>

  val currentVersion: Version

  def impl([#i1: I1#]): O

  def apply([#i1: ValueWithProvenance[I1]#], v: ValueWithProvenance[Version] = currentVersion)(implicit ct: ClassTag[O], ec: Encoder[O], dc: Decoder[O]): Call =
    Call([#i1#], v)

  protected def implVersion([#i1: I1#], v: Version): O = {
    if (v != currentVersion)
      throwInvalidVersionException(v)
    impl([#i1#])
  }

  // This method is "pulled-up" from Call into the function so it can be overridden
  // by provenance infrastructural functions.  In general, the impl() has access to only the raw values,
  // not the ValueWithProvenance[T] wrappers.

  protected def runCall(call: Call)(implicit rt: ResultTracker): Result = {
    implicit val ct: ClassTag[O] = call.getOutputClassTag
    val output: O = implVersion([#call.v1.resolve.output#], call.getVersionValue)
    Result(call, VirtualValue(output))(rt.getCurrentBuildInfo)
  }

  case class Call([#v1: ValueWithProvenance[I1]#], v: ValueWithProvenance[Version])(implicit ct: ClassTag[O], ec: Encoder[O], dc: Decoder[O])
    extends Function1CallWithProvenance[O, [#I1#]]([#v1#], v)(implVersion) with Serializable {

      val function = self

      val functionName: String = self.getClass.getName.stripSuffix("$")

      override def toString: String =
        self.getClass.getSimpleName.stripSuffix("$") + inputTuple.toString

      override def run(implicit rt: ResultTracker): Result =
        runCall(this)(rt)

      override def resolve(implicit rt: ResultTracker): Result =
        rt.resolve(this).asInstanceOf[Result]

      override def unresolve(implicit rt: ResultTracker): Call =
        unresolveInputs(rt).asInstanceOf[Call]

      def newResult(output: VirtualValue[O])(implicit bi: BuildInfo): Result =
        Result(this, output)(bi)

      def duplicate([#v1: ValueWithProvenance[I1]#], v: ValueWithProvenance[Version]): Call =
        copy([#v1#], v)

      //
  
      override def inputTuple: Tuple1[[#ValueWithProvenance[I1]#]] = Tuple1([#v1#])

      override def resolveInputs(implicit rt: ResultTracker): Call =
        nocopy(duplicate([#v1.resolve#], v.resolve), this)

      override def unresolveInputs(implicit rt: ResultTracker): Call =
        nocopy(duplicate([#v1.unresolve#], v.unresolve), this)

      override def inflateInputs(implicit rt: ResultTracker): Call =
        nocopy(duplicate([#v1.inflate#], v.inflate), this)

      override def deflateInputs(implicit rt: ResultTracker): Call =
        nocopy(duplicate([#v1.deflate#], v.inflate), this)
  }

  object Call {
    implicit def encoder = Util.rawEncoder[Call]
    implicit def decoder = Util.rawDecoder[Call]
  }

  case class Result(call: Call, data: VirtualValue[O])(implicit bi: BuildInfo)
    extends Function1CallResultWithProvenance(call, data)(bi)

  implicit private def convertResult(r: Function1CallResultWithProvenance[O, [#I1#]]): Result =
    Result(r.provenance, r.getOutputVirtual)(r.getOutputBuildInfoBrief)

  implicit private def convertProvenance(f: Function1CallWithProvenance[O, [#I1#]]): Call = {
    val i = f.inputTuple
    Call([#i._1#], f.getVersion)(f.getOutputClassTag, f.getEncoder, f.getDecoder)
  }
}#
]
