package com.cibo.provenance

/**
  * Created by ssmith on 9/12/17.
  *
  * This template file implements the 22 sub-classes Function{0..21} of function.
  *
  * These classes are autogenerated from boilerplate as Function{0..21}WithProvenance[O, {I1, I2, ...}].
  *
  *
  */

import io.circe.{Decoder, Encoder}
import java.io.Serializable
import java.time.Instant

import scala.util.Try
import scala.language.existentials
import scala.language.implicitConversions
import scala.reflect.ClassTag
import scala.reflect.runtime.currentMirror
import scala.reflect.runtime.universe.TypeTag

/**
  * Function{N}WithProvenance acts as the basic building block of data tracking in the provenance library.
  *
  * @tparam O:      The output type of the function.
  *
  * Type params I1..I21 in subclasses go with the input types of the function, applicable to the function arity.
  *
  * Implement the internal function body as:
  *   def impl(i1: I1, i2, I2, ...): O = ???
  *
  * And specify a version number, changing it when there is a logic change (not pure refactor):
  *   val currentVersion = Version("0.1")
  *
  * When a FunctionWithProvenance is "applied", it returns a MyFunction.Call (Function{n}CallWithProvenance).
  * This does no real work.  It represents the potential to call the funciton, or to look up a call made in the past.
  *
  * When that call is "resolved", it returns a MyFunction.Result (Function{n}CallResultWithProvenance).
  * This containst the `.output` (of type O), plus access to the `.call`, and each of the calls inputs, recursively.
  *
  */
@SerialVersionUID(10001L)
abstract class FunctionWithProvenance[O : Codec] extends Serializable {
  import com.cibo.provenance.exceptions.{UnknownVersionException, UnrunnableVersionException}

  // The currentVersion must be a single constant value in any given function instance object.
  val currentVersion: Version

  def outputClassTag = outputCodec.classTag
  def outputCodec = implicitly[Codec[O]]

  // By default only the current version is loadable and runnable.
  // These can be overridden if the software needs support for multiple historical versions at once
  // beyond history tracking.

  lazy val loadableVersions: Seq[Version] = Seq(currentVersion)
  lazy val runnableVersions: Seq[Version] = Seq(currentVersion)

  lazy val loadableVersionSet: Set[Version] = loadableVersions.toSet
  lazy val runnableVersionSet: Set[Version] = runnableVersions.toSet

  protected def throwInvalidVersionException(v: Version): Unit = {
    if (runnableVersions.contains(v)) {
      throw new RuntimeException(
        f"Version $v of $this is in the runnableVersions list, but implVersion is not overridden to handle it!"
      )
    } else if (loadableVersions.contains(v)) {
      throw UnrunnableVersionException(v, this)
    } else {
      throw UnknownVersionException(v, this)
    }
  }

  def deserializeCall(callSerialized: FunctionCallWithProvenanceSerializable)(implicit rt: ResultTracker): FunctionCallWithProvenance[O]

  // Naming:

  /**
    * This is the name of the function minus any type parameters.
    */
  lazy val baseName: String = getClass.getName.stripSuffix("$")

  /**
    * The names of the types of the type parameters: ie MapWithProvenance[A, S[_], B] might return
    * ["scala.Int", "scala.collection.immutable.List", "String"].
    */
  lazy val typeParameterTypeNames: Seq[String] = {
    val tp = getClass.getTypeParameters
    if (tp.isEmpty)
      Seq.empty
    else
    // TODO: If possible figure out how to dig this out.
    // We have the instance at this point, so it is fine to do at runtime.
    // f"for ${tp.toList.map(_.getName)}"
      throw new ReflectionException(
        f"FunctionWithProvenance $baseName should override `typeParameterTypeNames`!"
      )
  }

  /**
    * The fully qualified name of a function.
    */
  lazy val name: String =
    if (typeParameterTypeNames.isEmpty)
      baseName
    else
      baseName+ "[" + typeParameterTypeNames.mkString(",") + "]"

  override def toString = f"$name@$currentVersion"


  /**
    * Return all calls of this function that have data in a given (implicit) ResultTracker.
    *
    * This returns a degenerate form of the calls with types expressed as strings by name.
    * The data from this is durable across changes in the codebase.
    *
    * @param rt   The implicit ResultTracker.
    * @return     An Iterable[FunctionCallWithKnownProvenanceSerializableWithInputs].
    */
  def findCallData()(implicit rt: ResultTracker): Iterable[FunctionCallWithKnownProvenanceSerializableWithInputs] =
    rt.findCallData(name)

  /**
    * Return all calls of this function that have data in a given (implicit) ResultTracker.
    *
    * This returns a degenerate form of the calls with types expressed as strings by name.
    * The data from this is durable across changes in the codebase.
    *
    * @param version  Limit results to the specified version of the function.
    * @param rt   The implicit ResultTracker.
    * @return     An Iterable[FunctionCallWithKnownProvenanceSerializableWithInputs].
    */
  def findCallData(version: Version)(implicit rt: ResultTracker): Iterable[FunctionCallWithKnownProvenanceSerializableWithInputs] =
    rt.findCallData(name, version)

  /**
    * Return all results of this function that have data in a given (implicit) ResultTracker.
    *
    * This returns a degenerate form of the results with types expressed as strings by name.
    * The data from this is durable across changes in the codebase.
    *
    * @param rt   The implicit ResultTracker.
    * @return     An Iterable[FunctionCallResultWithKnownProvenanceSerializable].
    */
  def findResultData()(implicit rt: ResultTracker): Iterable[FunctionCallResultWithKnownProvenanceSerializable] =
    rt.findResultData(name)

  /**
    * Return all results of this function that have data in a given (implicit) ResultTracker.
    *
    * This returns a degenerate form of the results with types expressed as strings by name.
    * The data from this is durable across changes in the codebase.
    *
    * @param version  Limit results to the specified version of the function.
    * @param rt   The implicit ResultTracker.
    * @return     An Iterable[FunctionCallResultWithKnownProvenanceSerializable].
    */
  def findResultData(version: Version)(implicit rt: ResultTracker): Iterable[FunctionCallResultWithKnownProvenanceSerializable] =
    rt.findResultData(name, version)

  /**
    * Return all results tagged with the specified tag.
    *
    * This returns a degenerate form of the results with types expressed as strings by name.
    * The data from this is durable across changes in the codebase.
    *
    * @param text The text of the tag to search for.
    * @param rt   The implicit ResultTracker.
    * @return     An Iterable[FunctionCallResultWithKnownProvenanceSerializable].
    */
  def findResultDataByTag(tagText: String)(implicit rt: ResultTracker): Iterable[FunctionCallResultWithKnownProvenanceSerializable] =
    findResultDataByTag(tag = Tag(tagText))

  /**
    * Return all results tagged with the specified text string.
    *
    * This returns a degenerate form of the results with types expressed as strings by name.
    * The data from this is durable across changes in the codebase.
    *
    * @param tag  A Tag of text string annotation.
    * @param rt   The implicit ResultTracker.
    * @return     An Iterable[FunctionCallResultWithKnownProvenanceSerializable].
    */
  def findResultDataByTag(tag: Tag)(implicit rt: ResultTracker): Iterable[FunctionCallResultWithKnownProvenanceSerializable] =
    rt.findResultDataByTag(tag).filter(
      _.call.asInstanceOf[FunctionCallWithKnownProvenanceSerializable].functionName == name
    ).map(_.asInstanceOf[FunctionCallResultWithKnownProvenanceSerializable])

  def findTagResultData(implicit rt: ResultTracker): Iterable[TagHistoryEntry] =
    rt.findTagApplicationsByResultFunctionName(name)

  def findTags(implicit rt: ResultTracker): Iterable[Tag] = findTagResultData.map(_.tag)

  class ReflectionException(msg: String) extends RuntimeException(msg)
}


object FunctionWithProvenance {

  implicit def codec[T <: FunctionWithProvenance[_] : ClassTag : TypeTag]: Codec[T] =
    Codec(encoder, decoder)

  implicit def encoder[T <: FunctionWithProvenance[_] : ClassTag : TypeTag]: Encoder[T] =
    Encoder.forProduct2("name", "version") {
      obj =>
        val ct = implicitly[ClassTag[T]]
        val tt = implicitly[TypeTag[T]]
        Tuple2(obj.name, obj.currentVersion.id)
    }

  implicit def decoder[T <: FunctionWithProvenance[_] : ClassTag : TypeTag]: Decoder[T] =
    Decoder.forProduct2("name", "version") {
      (n: String, v: String) =>
        getByNameAndVersion(n.toString, Version(v.toString)).asInstanceOf[T]
    }

  def getByNameAndVersion(name: String, version: Version): FunctionWithProvenance[_] = {
    val f = getByName(name)
    if (f.currentVersion != version)
      throw new RuntimeException(f"Cannot load functions at a version besides the currentVersion ${f.currentVersion}!")
    f
  }

  def getByName(name: String): FunctionWithProvenance[_] =
    Codec.objectFromSerializableName[FunctionWithProvenance[_]](name)

}


/**
  * A Function0 with per-function versioning, and intermediate `.Call` and `.Result` tracking.
  *
  * @tparam O:   The output type.
  */
abstract class Function0WithProvenance[O : Codec] extends FunctionWithProvenance[O] with Serializable {
  self =>

  /**
    * Each Function0WithProvenance should declare a currentVersion, and update this value
    * whenever the impl() logic will return different values for the same inputs.
    *
    * @return Version: A value like Version("0.1")
    */
  val currentVersion: Version

  /**
    * This is the actual logic for the Function0WithProvenance.  It should be deterministic
    * for the given currentVersion value.
    *
    * It is typically not called directly except in tests.  The .resolve() method uses
    * it to create new results only when necessary.
    *
    * @return O: A value of the appropriate output type.
    */
  def impl(): O

  /**
    * The apply() method on a function returns a `.Call` of the current Function0WithProvenance.
    * The Call capture parameters and the function version (defaulting to currentVersion).
    *
    * Creating a `.Call` does not execute the implementation (impl()), and is ResultTracker (DB) agnostic.
    * The call can be run later, or it can be used to do queries for previous results, sent as a message
    * to a remote system, or otherwise interrogated and composed.
    *
    * @param v    The version of the function to use.  Defaults to currentVersion.
    * @param ct   An implicit class tag for the output type O.
    * @param ec   An implicit circe encoder for the output type O.
    * @param dc   An implicit circe decoder for the output type O.
    * @return     A `.Call` specific to this function (i.e. `MyFunction.Call`)
    */
  def apply(v: ValueWithProvenance[Version] = currentVersion): Call = Call(v)

  /**
    * This method is just like impl, but also recieves the Version of the call as a parameter.
    * By default it throws an exception for any version that is not the currentVersion.  To support alternate handling
    * of other versions, override this method, and have it selectively handle those.
    *
    * See examples in the test suite if you need to support multiple versions of logic at once.  Recommended practice
    * is support legacy logic with methods with names like impl5_6_7 to support legacy version 5.6.7.
    *
    * @param v:   The version to run.
    * @return O   An output value.
    */
  protected def implVersion(v: Version): O = {
    if (v != currentVersion)
      throwInvalidVersionException(v)
    impl()
  }

  /**
    * This method is "pulled-up" from Call.run() into the wrapping function so it can be overridden
    * by provenance library infrastructural functions.
    *
    * In general, the impl() has access to only the raw values, not the ValueWithProvenance[T] wrappers.
    * This allows collections, options, and mapping functions to do more complicated things when run() occurs.
    *
    * @param call:  The call to run
    * @param rt:    The implicit ResultTracker in context at execution time.
    * @return       A Result applicable to the call, with the output and current BuildInfo metadata.:q!
    */
  protected def runCall(call: Call)(implicit rt: ResultTracker): Result = {
    // This replaces an inputs that are not resolved with the equivalent result.
    // (Optimized to be a no-op if the call already has reolved inputs.)
    // Consider throwing an error if all inputs are not resolved first?  Perhaps we do too much.
    val cx = call.resolveInputs
    // The "resolve" invocations below will be no-ops because of the above.
    val output: O = implVersion(cx.versionValue)
    // Return a result referencing the fully resolved call.
    Result(cx, VirtualValue(output))(rt.currentAppBuildInfo)
  }

  def deserializeCall(s: FunctionCallWithProvenanceSerializable)(implicit rt: ResultTracker): Call = {
    val ss = s.asInstanceOf[FunctionCallWithKnownProvenanceSerializableWithInputs]
    val i = ss.inputList.toVector
    Call(UnknownProvenance(ss.functionVersion))
  }

  object Call {
    implicit def encoder(implicit rt: ResultTracker): Encoder[Call] = new ValueWithProvenanceEncoder[O, Call]
    implicit def decoder(implicit rt: ResultTracker): Decoder[Call] = new ValueWithProvenanceDecoder[O, Call]
  }

  /**
    * The Call inner class is a Function0CallWithProvenance
    * that is specific to this particular Function0WithProvenance.
    *
    * There are no inputs for a Function0WithProvenance, so unlike its kin it just takes a Version.
    *
    * @param v:     The Version of the function.
    */
  case class Call(v: ValueWithProvenance[Version] = currentVersion)
      extends Function0CallWithProvenance[O](v)(implVersion) {

    val function = self

    val functionName: String = self.name

    override def toString: String =
      self.getClass.getSimpleName.stripSuffix("$") + "()" // no Tuple0

    override def resolve(implicit rt: ResultTracker): Result =
      super.resolve(rt).asInstanceOf[Result]

    override def unresolve(implicit rt: ResultTracker): Call =
      super.unresolve(rt).asInstanceOf[Call]

    override def normalize(implicit rt: ResultTracker): Call =
      unresolve(rt)

    def newResult(output: VirtualValue[O])(implicit bi: BuildInfo): Result =
      Result(this, output)(bi)

    def duplicate(vv: ValueWithProvenance[Version]): Call =
      copy(vv)

    //

    override def resolveInputs(implicit rt: ResultTracker): Call =
      nocopy(duplicate(v.resolve), this)

    override def unresolveInputs(implicit rt: ResultTracker): Call =
      nocopy(duplicate(v.unresolve), this)

    override def loadInputs(implicit rt: ResultTracker): Call =
      nocopy(duplicate(v.load), this)

    override def loadRecurse(implicit rt: ResultTracker): Call =
      nocopy(duplicate(v.loadRecurse), this)

    override def saveInputs(implicit rt: ResultTracker): Call =
      nocopy(duplicate(v.load), this)

    override def run(implicit rt: ResultTracker): Result =
      runCall(this)(rt)
  }

  /**
    * The Result inner class is a Function0CallResultWithProvenance
    * that is specific to this particular Function0WithProvenance.
    *
    * @param call:                  The Call from which this Result was generated, capturing parameters and version.
    * @param outputAsVirtualValue   The output for the given inputs at the specified version.
    * @param bi:                    The implicit BuildInfo for the app that produced the output.
    */
  case class Result(override val call: Call, override val outputAsVirtualValue: VirtualValue[O])(implicit bi: BuildInfo)
    extends Function0CallResultWithProvenance(call, outputAsVirtualValue)(bi) {

    def normalize(implicit rt: ResultTracker): Result =
      Result(call.unresolve, outputAsVirtualValue.resolveDigest)(bi.abbreviate)

    def expandBuildInfo(implicit rt: ResultTracker): FunctionCallResultWithProvenance[O] =
      Result(call, outputAsVirtualValue)(rt.loadBuildInfoOption(bi.commitId, bi.buildId).get)
  }

  /**
    * Implicitly re-package a Function0CallWithProvenance into one specific to this Function0WithProvenance.
    * This ensures that type signatures never get less specific than necessary.
    *
    * @param call   Some Function0CallWithProvenance.
    * @return       A ThisFunction.Call.
    */
  implicit private def convertCall(call: Function0CallWithProvenance[O]): Call =
    Call(call.version)

  /**
    * Implicitly re-package generic Function0CallResultWithProvenance into one specific to this Function0WithProvenance.
    * This ensures that type signatures never get less specific than necessary.
    *
    * @param result Some Function0CallResultWithProvenance.
    * @return       A ThisFunction.Result
    */
  implicit private def convertResult(result: Function0CallResultWithProvenance[O]): Result =
    Result(result.call, result.outputAsVirtualValue)(result.outputBuildInfoBrief)


  /**
    * Return all versions of this function that have data in a given (implicit) ResultTracker.
    *
    * @param rt   The implicit ResultTracker.
    * @return     An Iterable[Version].
    */
  def findVersions(implicit rt: ResultTracker): Iterable[Version] =
    rt.findFunctionVersions(self.name)

  /**
    * Return all calls of this function that have data in a given (implicit) ResultTracker.
    *
    * Note: Some calls might not instantiate if the class has changed.  Use findCallData
    * for a degenerate form that will always return.
    *
    * @param rt   The implicit ResultTracker.
    * @return     An Iterable[Version].
    */
  def findCalls()(implicit rt: ResultTracker): Iterable[Call] =
    rt.findCallData(self.name).flatMap(_.tryLoadAs[Call].toOption).map(_.unresolveInputs)

  /**
    * Return all calls of this function that have data in a given (implicit) ResultTracker.
    *
    * Note: Some calls might not instantiate if the class has changed.  Use findCallData
    * for a degenerate form that will always return.
    *
    * @param version  Limit results to the specified version of the function.
    * @param rt       The implicit ResultTracker.
    * @return         An Iterable[Version].
    */
  def findCalls(version: Version)(implicit rt: ResultTracker): Iterable[Call] =
    rt.findCallData(self.name, version).flatMap(_.tryLoadAs[Call].toOption).map(_.unresolveInputs)

  /**
    * Return all results of this function that have data in a given (implicit) ResultTracker.
    *
    * Note: Some calls might not instantiate if the class has changed.  Use findCallData
    * for a degenerate form that will always return.
    *
    * @param rt   The implicit ResultTracker.
    * @return     An Iterable[Version].
    */
  def findResults()(implicit rt: ResultTracker): Iterable[Result] =
    rt.findResultData(self.name).flatMap(_.tryLoadAs[Result].toOption)

  /**
    * Return all results of this function that have data in a given (implicit) ResultTracker.
    *
    * Note: Some calls might not instantiate if the class has changed.  Use findCallData
    * for a degenerate form that will always return.
    *
    * @param version  Limit results to the specified version of the function.
    * @param rt       The implicit ResultTracker.
    * @return         An Iterable[Version].
    */
  def findResults(version: Version)(implicit rt: ResultTracker): Iterable[Result] =
    rt.findResultData(self.name, version).flatMap(_.tryLoadAs[Result].toOption)

  /**
    * Return all results tagged with the specified tag.
    *
    * Note: Some calls might not instantiate if the class has changed.
    * Use findResultDataByTag for a degenerate form of result that will always materialize.
    *
    * @param tag  A Tag of text string annotation.
    * @param rt   The implicit ResultTracker.
    * @return     An Iterable[FunctionCallResultWithKnownProvenanceSerializable].
    */
  def findResultsByTag(tagText: String)(implicit rt: ResultTracker): Iterable[Result] =
    findResultsByTag(Tag(tagText))

  /**
    * Return all results tagged with the specified text string.
    *
    * Note: Some calls might not instantiate if the class has changed.
    * Use findResultDataByTag for a degenerate form of result that will always materialize.
    *
    * @param tag  A Tag of text string annotation.
    * @param rt   The implicit ResultTracker.
    * @return     An Iterable[FunctionCallResultWithKnownProvenanceSerializable].
    */
  def findResultsByTag(tag: Tag)(implicit rt: ResultTracker): Iterable[Result] =
    findResultDataByTag(tag).flatMap(_.tryLoadAs[Result].toOption)

}


[1..21#
/**
  * A Function1 with per-function versioning, and intermediate `.Call` and `.Result` tracking.
  *
  * @tparam O:      The output type.
  * [#@tparam I1:     The type of input 1.#
  * ]
  */
abstract class Function1WithProvenance[[#I1#], O](
  implicit oc: Codec[O]
) extends FunctionWithProvenance[O] with Serializable {
  self =>

  /**
    * Each Function1WithProvenance should declare a currentVersion, and update this value
    * whenever the impl() logic will return different values for the same inputs.
    *
    * @return Version: A value like Version("0.1")
    */
  val currentVersion: Version

  /**
    * This is the actual logic for the Function1WithProvenance.  It should be deterministic
    * for the given currentVersion value.
    *
    * It is typically not called directly except in tests.  The .resolve() method uses
    * it to create new results only when necessary.
    *
    * [#@param i1#
    * ]
    * @return O: A value of the appropriate output type.
    */
  def impl([#i1: I1#]): O

  /**
    * The apply() method on a function returns a `.Call` of the current Function1WithProvenance.
    * The Call capture parameters and the function version (defaulting to currentVersion).
    *
    * Creating a `.Call` does not execute the implementation (impl()), and is ResultTracker (DB) agnostic.
    * The call can be run later, or it can be used to do queries for previous results, sent as a message
    * to a remote system, or otherwise interrogated and composed.
    *
    * [#@param i1   Input 1 of type I1#
    * ]
    * @param v    The version of the function to use.  Defaults to currentVersion.
    * @param ct   An implicit class tag for the output type O.
    * @param ec   An implicit circe encoder for the output type O.
    * @param dc   An implicit circe decoder for the output type O.
    * @return     A `.Call` specific to this function (i.e. `MyFunction.Call`)
    */
  def apply([#i1: ValueWithProvenance[_ <: I1]#], v: ValueWithProvenance[Version] = currentVersion): Call =
    Call([#i1#], v)

  /**
    * This method is just like impl, but also recieves the Version of the call as a parameter.
    * By default it throws an exception for any version that is not the currentVersion.  To support alternate handling
    * of other versions, override this method, and have it selectively handle those.
    *
    * See examples in the test suite if you need to support multiple versions of logic at once.  Recommended practice
    * is support legacy logic with methods with names like impl5_6_7 to support legacy version 5.6.7.
    *
    * [#param i1    Input 1 of type I1#
    * ]
    * @param v:   The version to run.
    * @return O   An output value.
    */
  protected def implVersion([#i1: I1#], v: Version): O = {
    if (v != currentVersion)
      throwInvalidVersionException(v)
    impl([#i1#])
  }

  /**
    * This method is "pulled-up" from Call.run() into the wrapping function so it can be overridden
    * by provenance library infrastructural functions.
    *
    * In general, the impl() has access to only the raw values, not the ValueWithProvenance[T] wrappers.
    * This allows collections, options, and mapping functions to do more complicated things when run() occurs.
    *
    * @param call:  The call to run
    * @param rt:    The implicit ResultTracker in context at execution time.
    * @return       A Result applicable to the call, with the output and current BuildInfo metadata.:q!
    */
  protected def runCall(call: Call)(implicit rt: ResultTracker): Result = {
    // This replaces an inputs that are not resolved with the equivalent result.
    // (Optimized to be a no-op if the call already has reolved inputs.)
    // Consider throwing an error if all inputs are not resolved first?  Perhaps we do too much.
    val cx = call.resolveInputs
    // The "resolve" invocations below will be no-ops because of the above.
    val output: O = implVersion([#cx.i1.resolve.output#], cx.versionValue)
    // Return a result referencing the fully resolved call.
    Result(cx, VirtualValue(output))(rt.currentAppBuildInfo)
  }

  def deserializeCall(s: FunctionCallWithProvenanceSerializable)(implicit rt: ResultTracker): Call = {
    val ss = s.asInstanceOf[FunctionCallWithKnownProvenanceSerializableWithInputs]
    val i = ss.inputList.toVector.map(_.load)

    // If any inputs are resolved, also pass a resolved version.
    // This keeps the reloaded version symmetrical with the other data.
    val inputsResolved = i.filter { case _: com.cibo.provenance.Result[_] => true; case _ => false }

    val v = if (inputsResolved.nonEmpty)
              UnknownProvenance(ss.functionVersion).resolve
            else
              UnknownProvenance(ss.functionVersion)

    Call([#i(0).asInstanceOf[ValueWithProvenance[I1]]#], v)
  }

  object Call {
    implicit def encoder(implicit rt: ResultTracker): Encoder[Call] = new ValueWithProvenanceEncoder[O, Call]
    implicit def decoder(implicit rt: ResultTracker): Decoder[Call] = new ValueWithProvenanceDecoder[O, Call]
  }

  /**
    * The Call inner class is a Function1CallWithProvenance
    * that is specific to this particular Function1WithProvenance.
    *
    * [#@param i1:    Input 1 of type I1#
    * ]
    * @param v:     The Version of the function.
    */
  case class Call([#i1: ValueWithProvenance[_ <: I1]#], v: ValueWithProvenance[Version])
    extends Function1CallWithProvenance[[#I1#], O]([#i1#], v)(implVersion) with Serializable {

      val function = self

      val functionName: String = self.name

      override def toString: String =
        self.getClass.getSimpleName.stripSuffix("$") + inputTuple.toString

      override def run(implicit rt: ResultTracker): Result =
        runCall(this)(rt)

      override def resolve(implicit rt: ResultTracker): Result =
        rt.resolve(this).asInstanceOf[Result]

      override def unresolve(implicit rt: ResultTracker): Call =
        unresolveInputs(rt).asInstanceOf[Call]

      override def normalize(implicit rt: ResultTracker): Call =
        super.normalize(rt).asInstanceOf[Call]

      def newResult(output: VirtualValue[O])(implicit bi: BuildInfo): Result =
        Result(this, output)(bi)

      def duplicate([#i1: ValueWithProvenance[_ <: I1]#], v: ValueWithProvenance[Version]): Call =
        copy([#i1#], v)

      //
  
      override def inputTuple: Tuple1[[#ValueWithProvenance[_ <: I1]#]] = Tuple1([#i1#])

      override def resolveInputs(implicit rt: ResultTracker): Call =
        nocopy(duplicate([#i1.resolve#], v.resolve), this)

      override def unresolveInputs(implicit rt: ResultTracker): Call =
        nocopy(duplicate([#i1.unresolve#], v.unresolve), this)

      override def loadInputs(implicit rt: ResultTracker): Call =
        nocopy(duplicate([#i1.load#], v.load), this)

      override def loadRecurse(implicit rt: ResultTracker): Call =
        nocopy(duplicate([#i1.loadRecurse#], v.loadRecurse), this)

      override def saveInputs(implicit rt: ResultTracker): Call =
        nocopy(duplicate([#i1.save#], v.load), this)
}

  /**
    * The Result inner class is a Function1CallResultWithProvenance
    * that is specific to this particular Function1WithProvenance.
    *
    * @param call:                  The Call from which this Result was generated, capturing parameters and version.
    * @param outputAsVirtualValue   The output for the given inputs at the specified version.
    * @param bi:                    The implicit BuildInfo for the app that produced the output.
    */
  case class Result(override val call: Call, override val outputAsVirtualValue: VirtualValue[O])(implicit bi: BuildInfo)
    extends Function1CallResultWithProvenance(call, outputAsVirtualValue)(bi) {

    def normalize(implicit rt: ResultTracker): Result =
      Result(call.unresolve, outputAsVirtualValue.resolveDigest)(bi.abbreviate)

    def expandBuildInfo(implicit rt: ResultTracker): FunctionCallResultWithProvenance[O] =
      Result(call, outputAsVirtualValue)(rt.loadBuildInfoOption(bi.commitId, bi.buildId).get)
  }

  /**
    * Implicitly re-package a Function1CallWithProvenance into one specific to this Function1WithProvenance.
    * This ensures that type signatures never get less specific than necessary.
    *
    * @param call   Some Function1CallWithProvenance.
    * @return       A ThisFunction.Call.
    */
  implicit private def convertCall(call: Function1CallWithProvenance[[#I1#], O]): Call = {
    val i = call.inputTuple
    Call([#i._1#], call.version)
  }

  /**
    * Implicitly re-package generic Function1CallResultWithProvenance into one specific to this Function1WithProvenance.
    * This ensures that type signatures never get less specific than necessary.
    *
    * @param result Some Function1CallResultWithProvenance.
    * @return       A ThisFunction.Result
    */
  implicit private def convertResult(r: Function1CallResultWithProvenance[[#I1#], O]): Result =
    Result(r.call, r.outputAsVirtualValue)(r.outputBuildInfoBrief)

  /**
    * Return all versions of this function that have data in a given (implicit) ResultTracker.
    *
    * @param rt   The implicit ResultTracker.
    * @return     An Iterable[Version].
    */
  def findVersions(implicit rt: ResultTracker): Iterable[Version] =
    rt.findFunctionVersions(self.name)

  /**
    * Return all calls of this function that have data in a given (implicit) ResultTracker.
    *
    * Note: Some calls might not instantiate if the class has changed.  Use findCallsHistorical
    * for a degenerate form that will always return.
    *
    * @param rt   The implicit ResultTracker.
    * @return     An Iterable[Version].
    */
  def findCalls()(implicit rt: ResultTracker): Iterable[Call] =
    rt.findCallData(self.name).flatMap(s => Try(s.load.asInstanceOf[Call]).toOption).map(_.unresolve)

  /**
    * Return all calls of this function that have data in a given (implicit) ResultTracker.
    *
    * Note: Some calls might not instantiate if the class has changed.  Use findCallsHistorical
    * for a degenerate form that will always return.
    *
    * @param version  Limit results to the specified version of the function.
    * @param rt       The implicit ResultTracker.
    * @return         An Iterable[Version].
    */
  def findCalls(version: Version)(implicit rt: ResultTracker): Iterable[Call] =
    rt.findCallData(self.name, version).flatMap(s => Try(s.load.asInstanceOf[Call]).toOption).map(_.unresolve)

  /**
    * Return all results of this function that have data in a given (implicit) ResultTracker.
    *
    * Note: Some calls might not instantiate if the class has changed.  Use findCallsHistorical
    * for a degenerate form that will always return.
    *
    * @param rt   The implicit ResultTracker.
    * @return     An Iterable[Version].
    */
  def findResults()(implicit rt: ResultTracker): Iterable[Result] =
    rt.findResultData(self.name).flatMap(s => Try(s.load.asInstanceOf[Result]).toOption)

  /**
    * Return all results of this function that have data in a given (implicit) ResultTracker.
    *
    * Note: Some calls might not instantiate if the class has changed.  Use findCallsHistorical
    * for a degenerate form that will always return.
    *
    * @param version  Limit results to the specified version of the function.
    * @param rt       The implicit ResultTracker.
    * @return         An Iterable[Version].
    */
  def findResults(version: Version)(implicit rt: ResultTracker): Iterable[Result] =
    rt.findResultData(self.name, version).flatMap(s => Try(s.load.asInstanceOf[Result]).toOption)

  /**
    * Return all results tagged with the specified tag.
    *
    * Note: Some calls might not instantiate if the class has changed.
    * Use findResultDataByTag for a degenerate form of result that will always materialize.
    *
    * @param tag  A Tag of text string annotation.
    * @param rt   The implicit ResultTracker.
    * @return     An Iterable[FunctionCallResultWithKnownProvenanceSerializable].
    */
  def findResultsByTag(tagText: String)(implicit rt: ResultTracker): Iterable[Result] =
    findResultsByTag(Tag(tagText))

  /**
    * Return all results tagged with the specified text string.
    *
    * Note: Some calls might not instantiate if the class has changed.
    * Use findResultDataByTag for a degenerate form of result that will always materialize.
    *
    * @param tag  A Tag of text string annotation.
    * @param rt   The implicit ResultTracker.
    * @return     An Iterable[FunctionCallResultWithKnownProvenanceSerializable].
    */
  def findResultsByTag(tag: Tag)(implicit rt: ResultTracker): Iterable[Result] =
    findResultDataByTag(tag).flatMap(_.tryLoadAs[Result].toOption)

}#
]
