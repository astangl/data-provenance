package com.cibo.provenance

/**
  * Created by ssmith on 9/11/17.
  *
  * Note: The FunctionCallWithProvenance code lives in VirtualValue.scala (sealed trait).
  *
  * This file contains the Function{N}CallSignatureWithProvenance subclass implementations.
  *
  */

import scala.language.implicitConversions
import scala.reflect.ClassTag

abstract class Function0CallWithProvenance[O : ClassTag](v: ValueWithProvenance[Version])(f: (Version) => O) extends FunctionCallWithProvenance[O](v) with Serializable {
  def impl = f
  def getInputs: Seq[ValueWithProvenance[_]] = Seq.empty
  def resolveInputs(implicit rt: ResultTracker): Function0CallWithProvenance[O] =
    nocopy(duplicate(v.resolve), this)
  def unresolveInputs(implicit rt: ResultTracker): Function0CallWithProvenance[O] =
    nocopy(duplicate(v.unresolve), this)
  def inflateInputs(implicit rt: ResultTracker): Function0CallWithProvenance[O] =
    nocopy(duplicate(v.inflate), this)
  def deflateInputs(implicit rt: ResultTracker): Function0CallWithProvenance[O] =
    nocopy(duplicate(v.inflate), this)
  def run(implicit rt: ResultTracker): Function0CallResultWithProvenance[O] = {
    val o: O = f(getVersionValue)
    new Function0CallResultWithProvenance(this, output = VirtualValue(o))(rt.getCurrentBuildInfo)
  }
  def newResult(value: VirtualValue[O])(implicit bi: BuildInfo): FunctionCallResultWithProvenance[O]
  def duplicate(vv: ValueWithProvenance[Version]): Function0CallWithProvenance[O]
}

[1..21#abstract class Function1CallWithProvenance[O : ClassTag, [#I1#]]([#i1: ValueWithProvenance[I1]#], v: ValueWithProvenance[Version])(f: ([#I1#], Version) => O) extends FunctionCallWithProvenance[O](v) with Serializable {
  def impl = f
  def getInputs: Seq[ValueWithProvenance[_]] = Seq([#i1#])
  def inputTuple: Tuple1[[#ValueWithProvenance[I1]#]] = Tuple1([#i1#])
  def resolveInputs(implicit rt: ResultTracker): Function1CallWithProvenance[O, [#I1#]] =
    nocopy(duplicate([#i1.resolve#], v.resolve), this)
  def unresolveInputs(implicit rt: ResultTracker): Function1CallWithProvenance[O, [#I1#]] =
    nocopy(duplicate([#i1.unresolve#], v.unresolve), this)
  def inflateInputs(implicit rt: ResultTracker): Function1CallWithProvenance[O, [#I1#]] =
    nocopy(duplicate([#i1.inflate#], v.inflate), this)
  def deflateInputs(implicit rt: ResultTracker): Function1CallWithProvenance[O, [#I1#]] =
    nocopy(duplicate([#i1.deflate#], v.inflate), this)
  def run(implicit rt: ResultTracker): Function1CallResultWithProvenance[O, [#I1#]] = {
    val output: O = f([#i1.resolve.output#], getVersionValue)
    new Function1CallResultWithProvenance(this, output = VirtualValue(output))(rt.getCurrentBuildInfo)
  }
  def newResult(value: VirtualValue[O])(implicit bi: BuildInfo): Function1CallResultWithProvenance[O, [#I1#]]
  def duplicate([#v1: ValueWithProvenance[I1]#], vv: ValueWithProvenance[Version]): Function1CallWithProvenance[O, [#I1#]]
}#
]

