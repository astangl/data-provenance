package com.cibo.provenance

import com.cibo.provenance._
import io.circe.{Decoder, Encoder}

import scala.reflect.ClassTag
import scala.reflect.runtime.universe.TypeTag

/** Extend the companion object of a class with ObjectCompanionN[...]:
  *
  * It offers:
  * - the .withProvenance(...) method wraps object construction with tracking.
  * - the ProvenanceWrapper implicit class is available to auto-wrap method calls.
  * - the ConstructorWithProvenance inner class lets you make alternate constructors
  * - the MethodWithProvenance inner class lets you make alternate method wrappers.
  *
  * Example:
  * ```
  * case class MyClass(foo: Foo, bar: Bar)
  *
  * object MyClass extends CompanionWithProvenance2[Foo, Bar, MyClass]
  *
  * // val objWithProvenance = MyClass.withProvenance(myFoo, myBar) // == MyClass(myFoo, myBar)
  *
  * or
  *
  * object MyClass extends CompanionWithProvenance2[Foo, Bar, MyClass]
  *
  *
  *
  * ```
  *
  * @param ev$1
  * @param ev$2
  * @tparam O
  */
abstract class ObjectCompanion[O : ClassTag : TypeTag] {
  implicit def encoder: Encoder[O]
  implicit def decoder: Decoder[O]
  implicit def codec: Codec[O] = Codec(encoder, decoder)

  val constructorWithProvenanceName: String = implicitly[ClassTag[O]].toString + ".withProvenance"

  // Sadly this cannot be detecte by just the compiler.  But fail fast if someone overrides.
  /*
  require(
    getClass.getMethods.toList.filter(m => m.getName == constructorWithProvenanceName).nonEmpty,
    f"Failed to find a method $constructorWithProvenanceName on ${implicitly[ClassTag[O]]}!  " +
    "If you override constructorWithProvenanceName, be sure to implement a method with that name."
  )
  */
}

/**
  * This is the base trait for ObjectCompanion{0..22}.ConstructorWithProvenance.
  */
trait ConstructorWithProvenance

trait MethodWithProvenance

/**
  * Use this as the base for companion objects when the related class needs provenance tracking,
  * and the related class has 0 parameters.
  *
  * It adds the .withProvenance(...) altrnate constructor to do object construction with tracking.
  */
abstract class ObjectCompanion0[O : ClassTag : TypeTag](v: Version) extends ObjectCompanion[O] {
  private val constructor = implicitly[ClassTag[O]].runtimeClass.getConstructor()

  trait ConstructorWithProvenance extends Function0WithProvenance[O] {
    val currentVersion: Version = v
    override lazy val name: String = constructorWithProvenanceName
    def impl(): O = {
      constructor.newInstance().asInstanceOf[O]
    }
  }

  lazy val withProvenance = new ConstructorWithProvenance {}
}

[1..21#
/**
  * Use this as the base for companion objects when the related class needs provenance tracking,
  * and the related class is a Product with arity 1.
  *
  * It adds the .withProvenance(...) altrnate constructor to do object construction with tracking.
  *
  */
abstract class ObjectCompanion1[[#I1 : Codec#], O : ClassTag : TypeTag](v: Version) extends ObjectCompanion[O] {
  [#
  private val c1: Class[_] = implicitly[Codec[I1]].classTag.runtimeClass.asInstanceOf[Class[I1]]#
  ]
  private val constructor = implicitly[Codec[O]].classTag.runtimeClass.getConstructor([#c1#])

  trait ConstructorWithProvenance extends Function1WithProvenance[[#I1#], O] {
    val currentVersion: Version = v
    override lazy val name: String = constructorWithProvenanceName
    def impl([#i1: I1#]): O = {
      constructor.newInstance([#i1.asInstanceOf[Object]#]).asInstanceOf[O]
    }
  }

  lazy val withProvenance = new ConstructorWithProvenance {}
}

#
]