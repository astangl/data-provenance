package com.cibo.provenance

/**
  * Created by ssmith on 9/12/17.
  *
  * This template file implements the 22 sub-classes Function{0..21} of function.
  *
  * These classes are autogenerated from boilerplate as Function{0..21}WithProvenance[O, {I1, I2, ...}].
  *
  *
  */

import io.circe.{Decoder, Encoder}
import java.io.Serializable

import com.cibo.provenance.FunctionWithProvenance.{getByName, getByNameAndVersion}

import scala.language.existentials
import scala.language.implicitConversions
import scala.reflect.ClassTag

/**
  * Function{N}WithProvenance acts as the basic building block of data tracking in the provenance library.
  *
  * @tparam: O The output type of the function.
  * @tparam: I1..I21 The input types of the function, applicable to the function arity.
  *
  * Implement the internal function body as:
  *   def impl(i1: I1, i2, I2, ...): O = ???
  *
  * And specify a version number, changing it when there is a logic change (not pure refactor):
  *   val currentVersion = Version("0.1")
  *
  * When a FunctionWithProvenance is "applied", it returns a MyFunction.Call (Function{n}CallWithProvenance).
  * This does no real work.  It represents the potential to call the funciton, or to look up a call made in the past.
  *
  * When that call is "resolved", it returns a MyFunction.Result (Function{n}CallResultWithProvenance).
  * This containst the `.output` (of type O), plus access to the `.call`, and each of the calls inputs, recursively.
  *
  */
@SerialVersionUID(10001L)
abstract class FunctionWithProvenance[O : ClassTag : Encoder : Decoder] extends Serializable {
  import com.cibo.provenance.exceptions.{UnknownVersionException, UnrunnableVersionException}

  def name: String = getClass.getName.stripSuffix("$")

  // The currentVersion must be a single constant value in any given function instance object.
  val currentVersion: Version
  
  override def toString = f"$name@$currentVersion"

  def outputClassTag = implicitly[ClassTag[O]]
  def outputEncoder = implicitly[Encoder[O]]
  def outputDecoder = implicitly[Decoder[O]]
  
  // By default only the current version is loadable and runnable.
  // These can be overridden if the software needs support for multiple historical versions at once
  // beyond history tracking.

  lazy val loadableVersions: Seq[Version] = Seq(currentVersion)
  lazy val runnableVersions: Seq[Version] = Seq(currentVersion)

  lazy val loadableVersionSet: Set[Version] = loadableVersions.toSet
  lazy val runnableVersionSet: Set[Version] = runnableVersions.toSet

  protected def throwInvalidVersionException(v: Version): Unit = {
    if (runnableVersions.contains(v)) {
      throw new RuntimeException(
        f"Version $v of $this is in the runnableVersions list, but implVersion is not overridden to handle it!"
      )
    } else if (loadableVersions.contains(v)) {
      throw UnrunnableVersionException(v, this)
    } else {
      throw UnknownVersionException(v, this)
    }
  }

  def deserializeCall(callSerialized: FunctionCallWithProvenanceSerializable)(implicit rt: ResultTracker): FunctionCallWithProvenance[O]
}


object FunctionWithProvenance {

  implicit def encoder[T <: FunctionWithProvenance[_]]: Encoder[T] =
    Encoder.forProduct2("name", "version") {
      obj =>
        Tuple2(obj.name, obj.currentVersion.id)
    }

  implicit def decoder[T <: FunctionWithProvenance[_]]: Decoder[T] =
    Decoder.forProduct2("name", "version") {
      (n: String, v: String) =>
        getByNameAndVersion(n.toString, Version(v.toString)).asInstanceOf[T]
    }

  def getByNameAndVersion(name: String, version: Version): FunctionWithProvenance[_] = {
    val f = getByName(name)
    if (f.currentVersion != version)
      throw new RuntimeException(f"Cannot load functions at a version besides the currentVersion ${f.currentVersion}!")
    f
  }

  def getByName(name: String): FunctionWithProvenance[_] = {
    val clazz = Class.forName(name + "$")
    val obj = clazz.getField("MODULE$").get(clazz)
    obj.asInstanceOf[FunctionWithProvenance[_]]
  }
}


/**
  * A Function0 with per-function versioning, and intermediate `.Call` and `.Result` tracking.
  *
  * @tparam O:   The output type.
  */
abstract class Function0WithProvenance[O : ClassTag : Encoder : Decoder] extends FunctionWithProvenance[O] with Serializable {
  self =>

  /**
    * Each Function0WithProvenance should declare a currentVersion, and update this value
    * whenever the impl() logic will return different values for the same inputs.
    *
    * @return Version: A value like Version("0.1")
    */
  val currentVersion: Version

  /**
    * This is the actual logic for the Function0WithProvenance.  It should be deterministic
    * for the given currentVersion value.
    *
    * It is typically not called directly except in tests.  The .resolve() method uses
    * it to create new results only when necessary.
    *
    * @return O: A value of the appropriate output type.
    */
  def impl(): O

  /**
    * The apply() method on a function returns a `.Call` of the current Function0WithProvenance.
    * The Call capture parameters and the function version (defaulting to currentVersion).
    *
    * Creating a `.Call` does not execute the implementation (impl()), and is ResultTracker (DB) agnostic.
    * The call can be run later, or it can be used to do queries for previous results, sent as a message
    * to a remote system, or otherwise interrogated and composed.
    *
    * @param v    The version of the function to use.  Defaults to currentVersion.
    * @param ct   An implicit class tag for the output type O.
    * @param ec   An implicit circe encoder for the output type O.
    * @param dc   An implicit circe decoder for the output type O.
    * @return     A `.Call` specific to this function (i.e. `MyFunction.Call`)
    */
  def apply(v: ValueWithProvenance[Version] = currentVersion): Call = Call(v)

  /**
    * This method is just like impl, but also recieves the Version of the call as a parameter.
    * By default it throws an exception for any version that is not the currentVersion.  To support alternate handling
    * of other versions, override this method, and have it selectively handle those.
    *
    * See examples in the test suite if you need to support multiple versions of logic at once.  Recommended practice
    * is support legacy logic with methods with names like impl5_6_7 to support legacy version 5.6.7.
    *
    * @param v:   The version to run.
    * @return O   An output value.
    */
  protected def implVersion(v: Version): O = {
    if (v != currentVersion)
      throwInvalidVersionException(v)
    impl()
  }
  /**
    * This method is "pulled-up" from Call.run() into the wrapping function so it can be overridden
    * by provenance library infrastructural functions.
    *
    * In general, the impl() has access to only the raw values, not the ValueWithProvenance[T] wrappers.
    * This allows collections, options, and mapping functions to do more complicated things when run() occurs.
    *
    * @param call:  The call to run
    * @param rt:    The implicit ResultTracker in context at execution time.
    * @return       A Result applicable to the call, with the output and current BuildInfo metadata.:q!
    */
  protected def runCall(call: Call)(implicit rt: ResultTracker): Result = {
    // This replaces an inputs that are not resolved with the equivalent result.
    // (Optimized to be a no-op if the call already has reolved inputs.)
    // Consider throwing an error if all inputs are not resolved first?  Perhaps we do too much.
    val cx = call.resolveInputs
    // The "resolve" invocations below will be no-ops because of the above.
    val output: O = implVersion(cx.versionValue)
    // Return a result referencing the fully resolved call.
    Result(cx, VirtualValue(output))(rt.currentAppBuildInfo)
  }

  def deserializeCall(s: FunctionCallWithProvenanceSerializable)(implicit rt: ResultTracker): Call = {
    val ss = s.asInstanceOf[FunctionCallWithKnownProvenanceSerializableWithInputs]
    val i = ss.inputList.toVector
    Call(ss.functionVersion)
  }

  object Call {
    implicit def encoder(implicit rt: ResultTracker): Encoder[Call] = new ValueWithProvenanceEncoder[O, Call]
    implicit def decoder(implicit rt: ResultTracker): Decoder[Call] = new ValueWithProvenanceDecoder[O, Call]
  }

  /**
    * The Call inner class is a Function0CallWithProvenance
    * that is specific to this particular Function0WithProvenance.
    *
    * There are no inputs for a Function0WithProvenance, so unlike its kin it just takes a Version.
    *
    * @param v:     The Version of the function.
    */
  case class Call(v: ValueWithProvenance[Version] = currentVersion)
    extends Function0CallWithProvenance[O](v)(implVersion) {

      val function = self
      val functionName: String = self.getClass.getName.stripSuffix("$")

      override def toString: String =
        self.getClass.getSimpleName.stripSuffix("$") + "()" // no Tuple0

      override def resolve(implicit rt: ResultTracker): Result =
        super.resolve(rt).asInstanceOf[Result]

      def newResult(output: VirtualValue[O])(implicit bi: BuildInfo): Result =
        Result(this, output)(bi)

      def duplicate(vv: ValueWithProvenance[Version]): Call =
        copy(v)
    
      //
      
      override def resolveInputs(implicit rt: ResultTracker): Call =
        nocopy(duplicate(v.resolve), this)

      override def unresolveInputs(implicit rt: ResultTracker): Call =
        nocopy(duplicate(v.unresolve), this)

      override def inflateInputs(implicit rt: ResultTracker): Call =
        nocopy(duplicate(v.inflate), this)

      override def inflateRecurse(implicit rt: ResultTracker): Call =
        nocopy(duplicate(v.inflateRecurse), this)

      override def deflateInputs(implicit rt: ResultTracker): Call =
        nocopy(duplicate(v.inflate), this)

      override def run(implicit rt: ResultTracker): Result =
        runCall(this)(rt)
  }

  /**
    * The Result inner class is a Function0CallResultWithProvenance
    * that is specific to this particular Function0WithProvenance.
    *
    * @param call:                  The Call from which this Result was generated, capturing parameters and version.
    * @param outputAsVirtualValue   The output for the given inputs at the specified version.
    * @param bi:                    The implicit BuildInfo for the app that produced the output.
    */
  case class Result(override val call: Call, override val outputAsVirtualValue: VirtualValue[O])(implicit bi: BuildInfo)
    extends Function0CallResultWithProvenance(call, outputAsVirtualValue)(bi)

  /**
    * Implicitly re-package a Function0CallWithProvenance into one specific to this Function0WithProvenance.
    * This ensures that type signatures never get less specific than necessary.
    *
    * @param call   Some Function0CallWithProvenance.
    * @return       A ThisFunction.Call.
    */
  implicit private def convertCall(call: Function0CallWithProvenance[O]): Call =
    Call(call.version)

  /**
    * Implicitly re-package generic Function0CallResultWithProvenance into one specific to this Function0WithProvenance.
    * This ensures that type signatures never get less specific than necessary.
    *
    * @param result Some Function0CallResultWithProvenance.
    * @return       A ThisFunction.Result
    */
  implicit private def convertResult(result: Function0CallResultWithProvenance[O]): Result =
    Result(result.call, result.outputAsVirtualValue)(result.outputBuildInfoBrief)

}

class Codec[T: Encoder : Decoder] {
  def encoder = implicitly[Encoder[T]]
  def decoder = implicitly[Decoder[T]]
}

object Codec {
  implicit def mk[T : Encoder : Decoder] = new Codec[T]

  implicit def mkOpt[T : Codec]: Codec[Option[T]] = {
    val c: Codec[T] = implicitly[Codec[T]]
    implicit val e: Encoder[T] = c.encoder
    implicit val d: Decoder[T] = c.decoder
    import io.circe.generic.semiauto._
    implicit val e2: Encoder[Option[T]] = deriveEncoder[Option[T]]
    implicit val d2: Decoder[Option[T]] = deriveDecoder[Option[T]]
    new Codec[Option[T]]
  }


  /*
  implicit val codecBoolean: Codec[Boolean] = {
    import io.circe.generic.auto._
    new Codec[Boolean]
  }

  implicit val rangeCodec: Codec[Range] = {
    import io.circe.generic.auto._
    new Codec[Range]
  }
  */
}

trait InputCodecGroup
case class InputCodecGroup0() extends InputCodecGroup


[1..21#

case class InputCodecGroup1[[#I1#]]([#c1: Codec[I1]#]) extends InputCodecGroup

/**
  * A Function1 with per-function versioning, and intermediate `.Call` and `.Result` tracking.
  *
  * @tparam O:      The output type.
  * [#@tparam I1:     The type of input 1.#
  * ]
  */
abstract class Function1WithProvenance[[#I1#], O](
  implicit ct: ClassTag[O],
  en: Encoder[O],
  de: Decoder[O],
  oc: Codec[O],
  ic: InputCodecGroup1[[#I1#]] = null
) extends FunctionWithProvenance[O] with Serializable {
  self =>

  assert(oc.encoder == en)
  assert(oc.decoder == de)

  /**
    * Each Function1WithProvenance should declare a currentVersion, and update this value
    * whenever the impl() logic will return different values for the same inputs.
    *
    * @return Version: A value like Version("0.1")
    */
  val currentVersion: Version

  /**
    * This is the actual logic for the Function1WithProvenance.  It should be deterministic
    * for the given currentVersion value.
    *
    * It is typically not called directly except in tests.  The .resolve() method uses
    * it to create new results only when necessary.
    *
    * [#@param i1#
    * ]
    * @return O: A value of the appropriate output type.
    */
  def impl([#i1: I1#]): O

  /**
    * The apply() method on a function returns a `.Call` of the current Function1WithProvenance.
    * The Call capture parameters and the function version (defaulting to currentVersion).
    *
    * Creating a `.Call` does not execute the implementation (impl()), and is ResultTracker (DB) agnostic.
    * The call can be run later, or it can be used to do queries for previous results, sent as a message
    * to a remote system, or otherwise interrogated and composed.
    *
    * [#@param i1   Input 1 of type I1#
    * ]
    * @param v    The version of the function to use.  Defaults to currentVersion.
    * @param ct   An implicit class tag for the output type O.
    * @param ec   An implicit circe encoder for the output type O.
    * @param dc   An implicit circe decoder for the output type O.
    * @return     A `.Call` specific to this function (i.e. `MyFunction.Call`)
    */
  def apply([#i1: ValueWithProvenance[_ <: I1]#], v: ValueWithProvenance[Version] = currentVersion): Call =
    Call([#i1#], v)

  /**
    * This method is just like impl, but also recieves the Version of the call as a parameter.
    * By default it throws an exception for any version that is not the currentVersion.  To support alternate handling
    * of other versions, override this method, and have it selectively handle those.
    *
    * See examples in the test suite if you need to support multiple versions of logic at once.  Recommended practice
    * is support legacy logic with methods with names like impl5_6_7 to support legacy version 5.6.7.
    *
    * [#param i1    Input 1 of type I1#
    * ]
    * @param v:   The version to run.
    * @return O   An output value.
    */
  protected def implVersion([#i1: I1#], v: Version): O = {
    if (v != currentVersion)
      throwInvalidVersionException(v)
    impl([#i1#])
  }

  /**
    * This method is "pulled-up" from Call.run() into the wrapping function so it can be overridden
    * by provenance library infrastructural functions.
    *
    * In general, the impl() has access to only the raw values, not the ValueWithProvenance[T] wrappers.
    * This allows collections, options, and mapping functions to do more complicated things when run() occurs.
    *
    * @param call:  The call to run
    * @param rt:    The implicit ResultTracker in context at execution time.
    * @return       A Result applicable to the call, with the output and current BuildInfo metadata.:q!
    */
  protected def runCall(call: Call)(implicit rt: ResultTracker): Result = {
    // This replaces an inputs that are not resolved with the equivalent result.
    // (Optimized to be a no-op if the call already has reolved inputs.)
    // Consider throwing an error if all inputs are not resolved first?  Perhaps we do too much.
    val cx = call.resolveInputs
    // The "resolve" invocations below will be no-ops because of the above.
    val output: O = implVersion([#cx.i1.resolve.output#], cx.versionValue)
    // Return a result referencing the fully resolved call.
    Result(cx, VirtualValue(output))(rt.currentAppBuildInfo)
  }

  def deserializeCall(s: FunctionCallWithProvenanceSerializable)(implicit rt: ResultTracker): Call = {
    val ss = s.asInstanceOf[FunctionCallWithKnownProvenanceSerializableWithInputs]
    val i = ss.inputList.toVector
    Call([#i(0).load.asInstanceOf[ValueWithProvenance[I1]]#], ss.functionVersion)
  }

  object Call {
    implicit def encoder(implicit rt: ResultTracker): Encoder[Call] = new ValueWithProvenanceEncoder[O, Call]
    implicit def decoder(implicit rt: ResultTracker): Decoder[Call] = new ValueWithProvenanceDecoder[O, Call]
  }

  /**
    * The Call inner class is a Function1CallWithProvenance
    * that is specific to this particular Function1WithProvenance.
    *
    * [#@param i1:    Input 1 of type I1#
    * ]
    * @param v:     The Version of the function.
    */
  case class Call([#i1: ValueWithProvenance[_ <: I1]#], v: ValueWithProvenance[Version])
    extends Function1CallWithProvenance[[#I1#], O]([#i1#], v)(implVersion) with Serializable {

      val function = self

      val functionName: String = self.getClass.getName.stripSuffix("$")

      override def toString: String =
        self.getClass.getSimpleName.stripSuffix("$") + inputTuple.toString

      override def run(implicit rt: ResultTracker): Result =
        runCall(this)(rt)

      override def resolve(implicit rt: ResultTracker): Result =
        rt.resolve(this).asInstanceOf[Result]

      override def unresolve(implicit rt: ResultTracker): Call =
        unresolveInputs(rt).asInstanceOf[Call]

      def newResult(output: VirtualValue[O])(implicit bi: BuildInfo): Result =
        Result(this, output)(bi)

      def duplicate([#i1: ValueWithProvenance[_ <: I1]#], v: ValueWithProvenance[Version]): Call =
        copy([#i1#], v)

      //
  
      override def inputTuple: Tuple1[[#ValueWithProvenance[_ <: I1]#]] = Tuple1([#i1#])

      override def resolveInputs(implicit rt: ResultTracker): Call =
        nocopy(duplicate([#i1.resolve#], v.resolve), this)

      override def unresolveInputs(implicit rt: ResultTracker): Call =
        nocopy(duplicate([#i1.unresolve#], v.unresolve), this)

      override def inflateInputs(implicit rt: ResultTracker): Call =
        nocopy(duplicate([#i1.inflate#], v.inflate), this)

      override def inflateRecurse(implicit rt: ResultTracker): Call =
        nocopy(duplicate([#i1.inflateRecurse#], v.inflateRecurse), this)

      override def deflateInputs(implicit rt: ResultTracker): Call =
        nocopy(duplicate([#i1.deflate#], v.inflate), this)
  }

  /**
    * The Result inner class is a Function1CallResultWithProvenance
    * that is specific to this particular Function1WithProvenance.
    *
    * @param call:                  The Call from which this Result was generated, capturing parameters and version.
    * @param outputAsVirtualValue   The output for the given inputs at the specified version.
    * @param bi:                    The implicit BuildInfo for the app that produced the output.
    */
  case class Result(override val call: Call, override val outputAsVirtualValue: VirtualValue[O])(implicit bi: BuildInfo)
    extends Function1CallResultWithProvenance(call, outputAsVirtualValue)(bi)

  /**
    * Implicitly re-package a Function1CallWithProvenance into one specific to this Function1WithProvenance.
    * This ensures that type signatures never get less specific than necessary.
    *
    * @param call   Some Function1CallWithProvenance.
    * @return       A ThisFunction.Call.
    */
  implicit private def convertCall(call: Function1CallWithProvenance[[#I1#], O]): Call = {
    val i = call.inputTuple
    Call([#i._1#], call.version)
  }

  /**
    * Implicitly re-package generic Function1CallResultWithProvenance into one specific to this Function1WithProvenance.
    * This ensures that type signatures never get less specific than necessary.
    *
    * @param result Some Function1CallResultWithProvenance.
    * @return       A ThisFunction.Result
    */
  implicit private def convertResult(r: Function1CallResultWithProvenance[[#I1#], O]): Result =
    Result(r.call, r.outputAsVirtualValue)(r.outputBuildInfoBrief)

}#
]
