package com.cibo.provenance

/**
  * Created by ssmith on 9/11/17.
  *
  * Note: The FunctionCallWithProvenance code lives in VirtualValue.scala (sealed trait).
  *
  * This file contains the Function{N}CallSignatureWithProvenance subclass implementations.
  *
  */

import scala.language.implicitConversions
import scala.reflect.ClassTag
import io.circe._


abstract class Function0CallWithProvenance[O : ClassTag : Encoder : Decoder](v: ValueWithProvenance[Version])(f: (Version) => O) extends FunctionCallWithProvenance[O](v) with Serializable {

  def impl = f

  def getInputs: Seq[ValueWithProvenance[_]] = Seq.empty

  // NOTE: Function0 has no inputTuple method, since there is no Tuple0.

  // NOTE: In most cases these methods are overridden by FunctionNWithProvenance.Call to return
  // the same object, but with a more specific known type.

  def resolveInputs(implicit rt: ResultTracker): Function0CallWithProvenance[O] =
    nocopy(duplicate(v.resolve), this)

  def unresolveInputs(implicit rt: ResultTracker): Function0CallWithProvenance[O] =
    nocopy(duplicate(v.unresolve), this)

  def inflateInputs(implicit rt: ResultTracker): Function0CallWithProvenance[O] =
    nocopy(duplicate(v.inflate), this)

  def deflateInputs(implicit rt: ResultTracker): Function0CallWithProvenance[O] =
    nocopy(duplicate(v.inflate), this)

  def run(implicit rt: ResultTracker): Function0CallResultWithProvenance[O] = {
    val o: O = f(getVersionValue)
    new Function0CallResultWithProvenance(this, output = VirtualValue(o))(rt.getCurrentBuildInfo)
  }

  def newResult(value: VirtualValue[O])(implicit bi: BuildInfo): FunctionCallResultWithProvenance[O]

  def duplicate(vv: ValueWithProvenance[Version]): Function0CallWithProvenance[O]
}

[1..21#abstract class Function1CallWithProvenance[O : ClassTag : Encoder : Decoder, [#I1#]]([#i1: ValueWithProvenance[I1]#], v: ValueWithProvenance[Version])(f: ([#I1#], Version) => O) extends FunctionCallWithProvenance[O](v) with Serializable {

  def impl = f

  def getInputs: Seq[ValueWithProvenance[_]] = Seq([#i1#])

  def inputTuple: Tuple1[[#ValueWithProvenance[I1]#]] = Tuple1([#i1#])

  // NOTE: In most cases these methods are overridden by FunctionNWithProvenance.Call to return
  // the same object, but with a more specific known type.

  def resolveInputs(implicit rt: ResultTracker): Function1CallWithProvenance[O, [#I1#]] =
    nocopy(duplicate([#i1.resolve#], v.resolve), this)

  def unresolveInputs(implicit rt: ResultTracker): Function1CallWithProvenance[O, [#I1#]] =
    nocopy(duplicate([#i1.unresolve#], v.unresolve), this)

  def inflateInputs(implicit rt: ResultTracker): Function1CallWithProvenance[O, [#I1#]] =
    nocopy(duplicate([#i1.inflate#], v.inflate), this)

  def deflateInputs(implicit rt: ResultTracker): Function1CallWithProvenance[O, [#I1#]] =
    nocopy(duplicate([#i1.deflate#], v.inflate), this)

  def run(implicit rt: ResultTracker): Function1CallResultWithProvenance[O, [#I1#]] = {
    val output: O = f([#i1.resolve.output#], getVersionValue)
    new Function1CallResultWithProvenance(this, output = VirtualValue(output))(rt.getCurrentBuildInfo)
  }

  def newResult(value: VirtualValue[O])(implicit bi: BuildInfo): Function1CallResultWithProvenance[O, [#I1#]]

  def duplicate([#v1: ValueWithProvenance[I1]#], vv: ValueWithProvenance[Version]): Function1CallWithProvenance[O, [#I1#]]
}#

]

